<!DOCTYPE html>
<html lang="lv">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>üí£ Bomb Puzzle Master - GR≈™TS RE≈Ωƒ™MS</title>
    <style>
        /* --- DIZAINS (NEKAS NAV MAINƒ™TS) --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            color: white; min-height: 100vh; overflow-x: hidden;
        }
        .fullscreen { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; overflow-y: auto; }
        .container { max-width: 1800px; margin: 0 auto; padding: 20px; }
        .header { text-align: center; margin-bottom: 30px; position: relative; }
        .title {
            font-size: 3rem; font-weight: bold;
            background: linear-gradient(45deg, #ff0000, #ff6b6b, #ff0000);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255,0,0,0.5); margin-bottom: 10px;
        }
        .subtitle { font-size: 1.2rem; color: #ff6b6b; margin-bottom: 20px; }
        .control-panel {
            position: fixed; top: 20px; right: 20px; display:flex; flex-direction:column; gap:10px; z-index:1000;
        }
        .control-btn {
            padding:12px 20px; font-size:1rem; font-weight:bold; border:none; border-radius:8px; cursor:pointer;
            transition: all .3s ease; background:#333; color:white; border:2px solid #555;
        }
        .control-btn:hover { transform: scale(1.05); background:#444; }
        .btn-connect { background: linear-gradient(45deg,#228B22,#32CD32); border-color:#00ff00; }
        .btn-disconnect { background: linear-gradient(45deg,#cc0000,#ff4444); border-color:#ff6666; }
        .btn-fullscreen { background: linear-gradient(45deg,#1a1a2e,#16213e); border-color:#00ccff; }
        .serial-status { padding:10px 15px; border-radius:5px; font-weight:bold; text-align:center; min-width:200px; }
        .serial-connected { background: rgba(34,139,34,0.2); color:#00ff00; border:2px solid #00ff00; }
        .serial-disconnected { background: rgba(204,0,0,0.2); color:#ff4444; border:2px solid #ff4444; }
        .columns { display:flex; gap:30px; margin-bottom:30px; }
        .hints-column { flex:1; min-width:450px; }
        .game-column { flex:2; min-width:700px; }
        .section-title { font-size:1.8rem; font-weight:bold; color:#00ccff; margin-bottom:15px; text-shadow:0 0 10px rgba(0,204,255,0.5); border-bottom:2px solid #00ccff; padding-bottom:5px; }
        .difficulty-badge { display:inline-block; padding:5px 15px; background: linear-gradient(45deg,#ff0000,#ff6b6b); color:white; border-radius:20px; font-weight:bold; margin-left:15px; font-size:1rem; }
        .hint-table { background: rgba(26,26,26,0.8); border-radius:15px; padding:20px; margin-bottom:20px; border:2px solid #333; backdrop-filter: blur(10px); }
        .hint-row { display:flex; align-items:center; margin-bottom:12px; padding:12px; background: rgba(42,42,42,0.9); border-radius:8px; border-left:4px solid #ff6b6b; transition: all .3s ease; }
        .hint-row:hover { transform: translateX(5px); border-left-color: #00ff00; }
        .color-dot { width:35px; height:35px; border-radius:50%; margin-right:10px; border:3px solid #444; display:inline-block; box-shadow:0 0 10px rgba(0,0,0,0.5); }
        .timer-section { text-align:center; margin-bottom:30px; background: rgba(26,26,26,0.8); border-radius:15px; padding:25px; border:2px solid #333; }
        .time-display { font-family:'Consolas', monospace; font-size:2.5rem; color:#ff4444; margin-bottom:20px; text-shadow:0 0 15px #ff4444; background: rgba(0,0,0,0.5); padding:15px; border-radius:10px; border:2px solid #ff4444; }
        .progress-bar { width:100%; height:25px; background:#333; border-radius:12px; overflow:hidden; margin-bottom:20px; border:2px solid #444; }
        .progress-fill { height:100%; background: linear-gradient(90deg,#ff0000,#ff6b6b,#ff0000); transition: width 1s linear; box-shadow:0 0 10px rgba(255,0,0,0.5); width:100%; }
        .timer-controls { display:flex; gap:20px; justify-content:center; margin-bottom:25px; }
        .btn { padding:15px 30px; font-size:1.3rem; font-weight:bold; border:none; border-radius:10px; cursor:pointer; transition:all .3s ease; box-shadow:0 5px 15px rgba(0,0,0,0.3); }
        .btn:hover { transform: translateY(-2px); box-shadow:0 8px 20px rgba(0,0,0,0.4); }
        .btn:active { transform: translateY(0); }
        .btn:disabled { opacity:0.6; cursor:not-allowed; transform:none; }
        .btn-start { background: linear-gradient(45deg,#228B22,#32CD32); color:white; }
        .btn-stop { background: linear-gradient(45deg,#cc0000,#ff4444); color:white; }
        .btn-delete { background: linear-gradient(45deg,#444,#666); color:white; }
        .btn-submit { background: linear-gradient(45deg,#228B22,#32CD32); color:white; }
        .current-input { text-align:center; margin-bottom:30px; padding:25px; background: rgba(26,26,26,0.8); border-radius:15px; border:2px solid #00ccff; }
        .current-input-text { font-size:1.5rem; color:white; min-height:50px; display:flex; align-items:center; justify-content:center; flex-wrap:wrap; gap:12px; padding:15px; background: rgba(0,0,0,0.3); border-radius:10px; border:1px solid #444; }
        .color-tag { padding:10px 20px; border-radius:25px; font-weight:bold; border:2px solid transparent; box-shadow:0 3px 10px rgba(0,0,0,0.3); transition:all .3s ease; }
        .color-tag:hover { transform: scale(1.05); border-color:white; }
        .actions { display:flex; gap:20px; justify-content:center; margin-bottom:30px; }
        .color-buttons { display:flex; gap:15px; justify-content:center; flex-wrap:wrap; margin-bottom:30px; }
        .color-btn { padding:18px 30px; font-size:1.3rem; font-weight:bold; border:none; border-radius:12px; cursor:pointer; transition:all .3s ease; min-width:140px; box-shadow:0 5px 15px rgba(0,0,0,0.3); border:3px solid transparent; }
        .color-btn:hover { transform: translateY(-3px) scale(1.05); box-shadow:0 8px 20px rgba(0,0,0,0.4); border-color:white; }
        .history-section { background: rgba(26,26,26,0.8); border-radius:15px; padding:25px; max-height:400px; overflow-y:auto; border:2px solid #333; }
        .history-row { display:flex; align-items:center; margin-bottom:12px; padding:12px; background: rgba(42,42,42,0.9); border-radius:8px; border-left:4px solid #00ccff; transition:all .3s ease; }
        .history-row:hover { transform: translateX(5px); background: rgba(50,50,50,0.9); }
        .hint-text { margin-left:20px; font-size:1.2rem; }
        .victory { color:#00ff00; font-weight:bold; text-shadow:0 0 10px #00ff00; }
        .defeat { color:#ff4444; font-weight:bold; text-shadow:0 0 10px #ff4444; }
        .penalty-warning { color:#ffaa00; font-size:0.9rem; margin-top:5px; }
        @media (max-width:1200px) {
            .columns { flex-direction:column; }
            .hints-column, .game-column { min-width:auto; }
            .control-panel { position:static; flex-direction:row; justify-content:center; margin-bottom:20px; }
        }
    </style>
</head>
<body>
    <div class="fullscreen">
        <div class="control-panel">
            <button class="control-btn btn-connect" onclick="connectSerial()">üîå CONNECT COM</button>
            <button class="control-btn btn-disconnect" onclick="disconnectSerial()">üî¥ DISCONNECT</button>
            <button class="control-btn btn-fullscreen" onclick="toggleFullscreen()">‚§¢ FULLSCREEN</button>
            <div class="serial-status serial-disconnected" id="serialStatus">COM: Nav savienots</div>
        </div>
        <div class="container">
            <div class="header">
                <h1 class="title">üí£ BOMB PUZZLE MASTER</h1>
                <div class="subtitle">GR≈™TS RE≈Ωƒ™MS <span class="difficulty-badge">HARD</span></div>
            </div>

            <div class="columns">
                <div class="hints-column">
                    <h2 class="section-title">SƒÅkotnƒìjie pavedieni: <span class="difficulty-badge">GR≈™TI</span></h2>
                    <div class="hint-table" id="hintsContainer"></div>
                </div>

                <div class="game-column">
                    <div class="timer-section">
                        <div class="time-display" id="timeDisplay">07:00</div>
                        <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
                        <div class="timer-controls">
                            <button class="btn btn-start" onclick="startTimer()">‚ñ∂Ô∏è START</button>
                            <button class="btn btn-stop" onclick="stopTimer()">‚è∏Ô∏è STOP</button>
                        </div>
                        <div class="penalty-warning">‚ö†Ô∏è Katra nepareiza mƒìƒ£inƒÅjuma sods: -30 sekundes!</div>
                    </div>

                    <div class="current-input">
                        <h3 class="section-title">Tava pa≈°reizƒìjƒÅ kombinƒÅcija:</h3>
                        <div class="current-input-text" id="currentInput">Izvƒìlies krƒÅsas...</div>
                    </div>

                    <div class="actions">
                        <button class="btn btn-delete" onclick="deleteLast()">‚¨ÖÔ∏è DZƒíST PEDƒíJO</button>
                        <button class="btn btn-submit" onclick="submitGuess()">‚úÖ IESNIEGT KODU</button>
                    </div>

                    <div class="color-buttons" id="colorButtons"></div>

                    <h3 class="section-title">Tavi mƒìƒ£inƒÅjumi:</h3>
                    <div class="history-section" id="historyContainer"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /* --- KONSTANTES --- */
        const CODE_LENGTH = 5;
        const TOTAL_TIME = 420; // 7 min≈´tes
        const PENALTY = 30;
        const POLL_INTERVAL = 100;

        // tikai ≈°ƒ´s 5 krƒÅsas (tƒÅ kƒÅ l≈´dzi)
        const COLORS = {
            "BTN1": { name: "Violets", color: "#8A2BE2", textColor: "white" },
            "BTN2": { name: "Zaƒº≈°", color: "#2E8B57", textColor: "white" },
            "BTN3": { name: "Balts", color: "#F8F8FF", textColor: "black" },
            "BTN4": { name: "Melns", color: "#000000", textColor: "white" },
            "BTN5": { name: "Pelƒìks", color: "#808080", textColor: "white" }
        };

        const ORDER = ["BTN1","BTN2","BTN3","BTN4","BTN5"];

        /* --- SPƒíLES STƒÄVOKLIS --- */
        const gameState = {
            secret: [],
            current: [],
            timeLeft: TOTAL_TIME,
            timerRunning: false,
            gameOver: false,
            serialPort: null,
            reader: null,
            generatedHints: [],
            history: []
        };

        document.addEventListener('DOMContentLoaded', () => {
            initializeGame();
            setupColorButtons();
            checkSerialSupport();
        });

        /* --- INICIALIZƒÄCIJA --- */
        function initializeGame() {
            gameState.secret = generateVeryHardSecret();
            gameState.generatedHints = generateEvenHarderHints();
            renderHints();
            updateTimerDisplay();
            updateCurrentInput();
            console.log("[DEBUG] Slepenais kods (BTN ids):", gameState.secret);
            console.log("[DEBUG] Slepenais kods (vƒÅrdi):", gameState.secret.map(c => COLORS[c].name));
        }

        /* --- SLEPENAIS KODS (ƒªOTI GR≈™TS) --- */
        function generateVeryHardSecret() {
            // vairƒÅk determinƒìti modeƒºi, lai liekas "cilvƒìciski sare≈æƒ£ƒ´ts"
            const patterns = [
                ['BTN1','BTN1','BTN2','BTN2','BTN3'],
                ['BTN4','BTN5','BTN4','BTN5','BTN4'],
                ['BTN1','BTN3','BTN5','BTN3','BTN1'],
                ['BTN2','BTN2','BTN4','BTN4','BTN1'],
                ['BTN5','BTN3','BTN5','BTN2','BTN5']
            ];
            let pattern = patterns[Math.floor(Math.random()*patterns.length)];
            // 60% izmai≈Üas (samaisa da≈æus elementus), bet neiznƒ´cina rakstu pilnƒ´gi
            if (Math.random() < 0.6) {
                let result = [...pattern];
                // maina 1-2 elementus uz nejau≈°ƒÅm krƒÅsƒÅm (lai nav pilnƒ´gi atklƒÅts)
                const changes = 1 + Math.floor(Math.random()*2); // 1 vai 2
                for (let i=0;i<changes;i++){
                    const pos = Math.floor(Math.random()*CODE_LENGTH);
                    result[pos] = ORDER[Math.floor(Math.random()*ORDER.length)];
                }
                return result;
            }
            return [...pattern];
        }

        /* --- ƒªOTI SMAGI, VILTIƒ¢I HINTI --- */
        function generateEvenHarderHints() {
            const hints = [];

            // Veids A: gandrƒ´z nejau≈°i (3-4 izmai≈Üas) - liek domƒÅt ka gandrƒ´z nekas nav pareizs
            for (let i=0;i<3;i++){
                let guess = [...gameState.secret];
                const changes = 3 + Math.floor(Math.random()*2); // 3 vai 4
                for (let j=0;j<changes;j++){
                    const pos = Math.floor(Math.random()*CODE_LENGTH);
                    guess[pos] = ORDER[Math.floor(Math.random()*ORDER.length)];
                }
                const r = evaluateGuess(guess, true);
                // padari noderƒ´bu zemu: samazini correctPos/wrongPlace, lai neaizdotu pƒÅrƒÅk daudz
                r.correctPos = Math.min(r.correctPos, 1);
                r.wrongPlace = Math.min(r.wrongPlace, 2);
                hints.push({guess, result: r, type: 'very_wrong'});
            }

            // Veids B: pareizas krƒÅsas, bet ƒ£enerƒì haotisku secƒ´bu (swapped / redistributed)
            for (let i=0;i<2;i++){
                let guess = shuffleArray([...gameState.secret]);
                // papildus sapildi ar swapiem, lai padarƒ´tu to maldino≈°u
                const swaps = 1 + Math.floor(Math.random()*2); // 1-2 swap
                for (let s=0;s<swaps;s++){
                    const a = Math.floor(Math.random()*CODE_LENGTH);
                    const b = Math.floor(Math.random()*CODE_LENGTH);
                    [guess[a], guess[b]] = [guess[b], guess[a]];
                }
                const r = evaluateGuess(guess, true);
                // noslƒÅpƒì centralizƒìto info
                r.correctPos = Math.min(r.correctPos, 2);
                r.wrongPlace = Math.min(r.wrongPlace, 3);
                hints.push({guess, result: r, type: 'swapped'});
            }

            // Veids C: gandrƒ´z pareizi, bet ar vienu viltƒ´gu nomai≈Üu
            {
                let guess = [...gameState.secret];
                const pos = Math.floor(Math.random()*CODE_LENGTH);
                // nomainƒÅm uz citu, taƒçu pƒÅrliecinƒÅmies ka kopƒìjais neƒºauj pilnƒ´gi atklƒÅt
                let newCol;
                do { newCol = ORDER[Math.floor(Math.random()*ORDER.length)]; } while (newCol === guess[pos]);
                guess[pos] = newCol;
                const r = evaluateGuess(guess, true);
                r.correctPos = Math.min(r.correctPos, 3);
                r.wrongPlace = Math.min(r.wrongPlace, 2);
                hints.push({guess, result: r, type: 'almost_correct'});
            }

            // sajauc un atgrie≈æ
            return shuffleArray(hints);
        }

        /* --- EVALUATE GUESS --- */
        function evaluateGuess(guess, preview = false) {
            const secretCopy = [...gameState.secret];
            const guessCopy = [...guess];
            let correctPos = 0;
            let wrongPlace = 0;

            for (let i = CODE_LENGTH - 1; i >= 0; i--) {
                if (guessCopy[i] === secretCopy[i]) {
                    correctPos++;
                    guessCopy.splice(i, 1);
                    secretCopy.splice(i, 1);
                }
            }
            for (const g of guessCopy) {
                const idx = secretCopy.indexOf(g);
                if (idx !== -1) {
                    wrongPlace++;
                    secretCopy.splice(idx, 1);
                }
            }

            // ja tas nav preview, piemƒìro sodu tikai, ja taimeris darbojas
            if (!preview && gameState.timerRunning && !gameState.gameOver) {
                gameState.timeLeft = Math.max(0, gameState.timeLeft - PENALTY);
                updateTimerDisplay();
            }

            return { correctPos, wrongPlace };
        }

        /* --- SERIAL API (Web Serial) --- */
        async function connectSerial() {
            try {
                if (!('serial' in navigator)) {
                    throw new Error('Web Serial API nav atbalstƒ´ta ≈°ajƒÅ pƒÅrl≈´kprogrammƒÅ');
                }
                gameState.serialPort = await navigator.serial.requestPort();
                await gameState.serialPort.open({ baudRate: 9600, dataBits: 8, stopBits: 1, parity: 'none' });
                updateSerialStatus(true);
                startSerialReading();
                console.log("[DEBUG] Serial connected");
            } catch (err) {
                console.error('Serial connection error:', err);
                updateSerialStatus(false, err.message || 'error');
                alert('Kƒº≈´da savienojoties ar COM portu: ' + (err.message || err));
            }
        }

        async function disconnectSerial() {
            try {
                if (gameState.reader) {
                    await gameState.reader.cancel();
                    gameState.reader = null;
                }
                if (gameState.serialPort) {
                    await gameState.serialPort.close();
                    gameState.serialPort = null;
                }
                updateSerialStatus(false, 'Atvienots');
                console.log("[DEBUG] Serial disconnected");
            } catch (err) {
                console.error('Disconnect error:', err);
            }
        }

        function updateSerialStatus(connected, message = '') {
            const el = document.getElementById('serialStatus');
            if (connected) {
                el.textContent = 'COM: Savienots ‚úì';
                el.className = 'serial-status serial-connected';
            } else {
                el.textContent = `COM: Nav savienots${message ? ' - ' + message : ''}`;
                el.className = 'serial-status serial-disconnected';
            }
        }

        async function startSerialReading() {
            try {
                const textDecoder = new TextDecoder();
                gameState.reader = gameState.serialPort.readable.getReader();
                while (true) {
                    const { value, done } = await gameState.reader.read();
                    if (done) {
                        break;
                    }
                    if (value) {
                        // value is a Uint8Array (or similar) ‚Äî decode and split by newlines
                        let chunk = textDecoder.decode(value);
                        // da≈æreiz vairƒÅkas komandas var nƒÅkt kopƒÅ; sadalƒÅm pa rindi≈ÜƒÅm
                        const lines = chunk.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
                        for (const line of lines) {
                            processSerialInput(line.toUpperCase());
                        }
                    }
                }
            } catch (err) {
                console.error('Serial reading error:', err);
                updateSerialStatus(false, 'Reading error');
            } finally {
                if (gameState.reader) {
                    try { gameState.reader.releaseLock(); } catch(e){}
                    gameState.reader = null;
                }
            }
        }

        function processSerialInput(text) {
            // atbalsta "BTN1".."BTN5" vai ciparus "1".."5"
            if (text.startsWith("BTN") && ORDER.includes(text.substring(0,4))) {
                addInput(text.substring(0,4));
            } else if (/^[1-5]$/.test(text)) {
                addInput(`BTN${text}`);
            } else {
                // debug: izvada citu negaidƒ´tu saturu
                console.log("[DEBUG] Nepazƒ´stams serial teksts:", text);
            }
        }

        function checkSerialSupport() {
            if (!('serial' in navigator)) {
                // neuzbƒÅzƒ´gi brƒ´dinƒÅm, bet nedraudam
                console.warn('Web Serial API nav pieejams ‚Äî izmanto Chrome/Edge/Opera ar HTTPS vai localhost.');
            }
        }

        /* --- UI RENDERING --- */
        function setupColorButtons() {
            const container = document.getElementById('colorButtons');
            container.innerHTML = '';
            for (const id of ORDER) {
                const color = COLORS[id];
                const btn = document.createElement('button');
                btn.className = 'color-btn';
                btn.textContent = color.name;
                btn.style.background = `linear-gradient(45deg, ${color.color}, ${adjustColor(color.color, 18)})`;
                btn.style.color = color.textColor;
                btn.style.border = `3px solid ${adjustColor(color.color, -30)}`;
                btn.onclick = () => addInput(id);
                container.appendChild(btn);
            }
        }

        // vienkƒÅr≈°a hex gaismas/tum≈°uma korekcija (pie≈Üem formu "#RRGGBB")
        function adjustColor(hex, percent) {
            // percent: negative => darker, positive => lighter
            try {
                const h = hex.replace('#','');
                const num = parseInt(h,16);
                let r = (num >> 16) + Math.round(255 * (percent/100));
                let g = ((num >> 8) & 0x00FF) + Math.round(255 * (percent/100));
                let b = (num & 0x0000FF) + Math.round(255 * (percent/100));
                r = Math.min(255, Math.max(0, r)); g = Math.min(255, Math.max(0, g)); b = Math.min(255, Math.max(0, b));
                const rr = r.toString(16).padStart(2,'0');
                const gg = g.toString(16).padStart(2,'0');
                const bb = b.toString(16).padStart(2,'0');
                return `#${rr}${gg}${bb}`;
            } catch (e) {
                return hex;
            }
        }

        function renderHints() {
            const container = document.getElementById('hintsContainer');
            container.innerHTML = '';
            gameState.generatedHints.forEach(h => {
                const row = document.createElement('div'); row.className = 'hint-row';
                if (h.type === 'almost_correct') row.style.borderLeftColor = '#ffaa00';
                else if (h.type === 'very_wrong') row.style.borderLeftColor = '#ff4444';
                else row.style.borderLeftColor = '#00ccff';

                // rƒÅdƒÅm tikai apaƒºos dotus (neiz≈Üemam dizainu)
                h.guess.forEach(gid => {
                    const dot = document.createElement('span'); dot.className = 'color-dot';
                    dot.style.backgroundColor = COLORS[gid].color;
                    dot.title = ''; // nerƒÅda nosaukumu, lai hinti b≈´tu gr≈´tƒÅki
                    row.appendChild(dot);
                });

                const text = document.createElement('span'); text.className = 'hint-text';
                let icon = '';
                if (h.type === 'almost_correct') icon = 'üî∏ ';
                else if (h.type === 'very_wrong') icon = '‚ùå ';
                else if (h.type === 'swapped') icon = 'üîÑ ';
                // mazliet noslƒÅpƒì tekstu (lai tie≈°ƒÅ info b≈´tu mazƒÅks)
                text.textContent = icon + obfuscateHintText(makeHintText(h.result));
                row.appendChild(text);
                container.appendChild(row);
            });
        }

        // ievieto "viltƒ´gu" tekstu, padara hintu mazƒÅk tie≈°u
        function obfuscateHintText(text) {
            // piemƒìram: "üîµ 2 vietƒÅ, 1 citur" -> "üîµ apm. 2 vietƒÅs / daƒºƒìji"
            // vienkƒÅr≈°i transformƒì da≈æas frƒÅzes uz neskaidrƒÅkƒÅm
            if (text.includes('vieg')) return text; // nav mainƒ´t, ja jau weird
            // ja ir "vietƒÅ" vai "citur", darƒÅm to mazƒÅk tie≈°u
            return text.replace(/(\d+) vieta/gi, (m, p1) => `${p1} (apt.) vietƒÅ`)
                       .replace(/(\d+) vietƒÅ/gi, (m,p1) => `${p1} (apt.) vietƒÅ`)
                       .replace(/vietƒÅ, (\d+) citur/gi, (m,p1) => `~${p1} citur`)
                       .replace(/vieta/gi, 'vieta')
                       ;
        }

        function makeHintText(data) {
            const c = data.correctPos;
            const w = data.wrongPlace;
            if (c === 0 && w === 0) return "üíÄ Nekas nav pareizs";
            if (c === 1 && w === 0) return "‚ù∂ 1 pareizs vietƒÅ";
            if (c > 1 && w === 0) return `üü¢ ${c} pareizi vietƒÅ`;
            if (c === 0 && w === 1) return "üü° 1 pareizs, bet citƒÅ vietƒÅ";
            if (c === 0 && w > 1) return `üü° ${w} pareizi, bet citƒÅs vietƒÅs`;
            return `üîµ ${c} vietƒÅ, ${w} citur`;
        }

        function updateCurrentInput() {
            const container = document.getElementById('currentInput');
            container.innerHTML = '';
            if (gameState.current.length === 0) {
                container.textContent = 'Izvƒìlies krƒÅsas...';
                return;
            }
            gameState.current.forEach(cid => {
                const color = COLORS[cid];
                const tag = document.createElement('span'); tag.className = 'color-tag';
                tag.textContent = color.name;
                tag.style.background = `linear-gradient(45deg, ${color.color}, ${adjustColor(color.color, 18)})`;
                tag.style.color = color.textColor;
                container.appendChild(tag);
            });
            // iesnieg≈°anas pogas status
            const submitBtn = document.querySelector('.btn-submit');
            if (submitBtn) submitBtn.disabled = gameState.current.length !== CODE_LENGTH;
        }

        function updateTimerDisplay() {
            const minutes = Math.floor(gameState.timeLeft / 60);
            const seconds = gameState.timeLeft % 60;
            document.getElementById('timeDisplay').textContent = `${minutes.toString().padStart(2,'0')}:${seconds.toString().padStart(2,'0')}`;
            // progresu rƒÅdƒÅm kƒÅ atlikumu (lai vizuƒÅli redz laika kritumu)
            const percentRemaining = (gameState.timeLeft / TOTAL_TIME) * 100;
            document.getElementById('progressFill').style.width = `${percentRemaining}%`;
            if (percentRemaining < 20) {
                document.getElementById('progressFill').style.background = 'linear-gradient(90deg, #ff0000, #ff4444)';
            } else if (percentRemaining < 50) {
                document.getElementById('progressFill').style.background = 'linear-gradient(90deg, #ff6b6b, #ffaa00)';
            } else {
                document.getElementById('progressFill').style.background = 'linear-gradient(90deg,#ff0000,#ff6b6b,#ff0000)';
            }
        }

        /* --- SPƒíLES LOƒ¢IKA --- */
        function addInput(btnId) {
            if (gameState.gameOver || gameState.current.length >= CODE_LENGTH) return;
            gameState.current.push(btnId);
            updateCurrentInput();
        }

        function deleteLast() {
            if (gameState.current.length>0) {
                gameState.current.pop();
                updateCurrentInput();
            }
        }

        function submitGuess() {
            if (gameState.current.length < CODE_LENGTH) {
                alert('‚ùå Nepilns kods! Ievadi visas 5 krƒÅsas pirms iesnieg≈°anas!');
                return;
            }
            const guess = [...gameState.current];
            gameState.current = [];
            updateCurrentInput();

            if (guess.join() === gameState.secret.join()) {
                endGame(true, guess);
                return;
            }
            if (gameState.timeLeft <= 0) {
                endGame(false, guess);
                return;
            }
            // dati par mƒìƒ£inƒÅjumu
            const hintData = evaluateGuess(guess);
            addToHistory(guess, hintData, 'try');
        }

        function addToHistory(guess, hintData, result) {
            const hist = document.getElementById('historyContainer');
            const row = document.createElement('div'); row.className = 'history-row';
            guess.forEach(gid => {
                const dot = document.createElement('span'); dot.className = 'color-dot';
                dot.style.backgroundColor = COLORS[gid].color;
                row.appendChild(dot);
            });
            const text = document.createElement('span'); text.className = 'hint-text';
            if (result === 'win') {
                text.textContent = 'üéâ UZVARA! Kods atminƒìts!';
                text.className += ' victory';
            } else if (result === 'lose') {
                text.textContent = 'üí£ ZAUDƒíJUMS! Laiks beidzies!';
                text.className += ' defeat';
            } else {
                text.textContent = makeHintText(hintData);
                text.innerHTML += ` <span style="color:#ff4444; font-size:0.9em;">(-${PENALTY}s)</span>`;
            }
            row.appendChild(text);
            hist.appendChild(row);
            hist.scrollTop = hist.scrollHeight;
            gameState.history.push({ guess, hintData, result });
        }

        /* --- TIMER --- */
        function startTimer() {
            if (!gameState.timerRunning && !gameState.gameOver) {
                gameState.timerRunning = true;
                // ja interval jau nav, uzstƒÅdƒÅm
                if (!gameState.timerInterval) {
                    gameState.timerInterval = setInterval(tick, 1000);
                }
            }
        }
        function stopTimer() {
            gameState.timerRunning = false;
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
                gameState.timerInterval = null;
            }
        }
        function tick() {
            if (gameState.timerRunning && !gameState.gameOver) {
                gameState.timeLeft--;
                if (gameState.timeLeft < 0) gameState.timeLeft = 0;
                updateTimerDisplay();
                if (gameState.timeLeft <= 0) {
                    endGame(false);
                }
            }
        }

        function endGame(victory, guess=null) {
            gameState.gameOver = true;
            stopTimer();
            if (guess) addToHistory(guess, null, victory ? 'win' : 'lose');
            setTimeout(() => {
                if (victory) {
                    alert('üéâ APSVEICAM! Tu atminƒìji ƒºoti gr≈´to kodu!');
                    // atver lapu pƒìc nelielas aizkaves
                    window.open('https://youtube.com', '_blank');
                } else {
                    alert('üí£ ZAUDƒíJI! ≈†oreiz neizdevƒÅs! Mƒìƒ£ini vƒìlreiz!');
                    window.open('https://ss.com', '_blank');
                }
            }, 700);
        }

        /* --- UTILITIES --- */
        function shuffleArray(a) {
            const arr = [...a];
            for (let i = arr.length-1; i>0; i--) {
                const j = Math.floor(Math.random()*(i+1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        /* --- PILNEKRƒÄNA --- */
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(err => console.error('Fullscreen error:', err));
            } else {
                document.exitFullscreen();
            }
        }
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.fullscreenElement) document.exitFullscreen();
        });

        /* --- EKSPORTƒí FUNKCIJAS GLOBƒÄLI --- */
        window.connectSerial = connectSerial;
        window.disconnectSerial = disconnectSerial;
        window.startTimer = startTimer;
        window.stopTimer = stopTimer;
        window.addInput = addInput;
        window.deleteLast = deleteLast;
        window.submitGuess = submitGuess;
        window.toggleFullscreen = toggleFullscreen;

    </script>
</body>
</html>
